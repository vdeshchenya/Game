#include "SystemOfParticles.h"void SystemOfParticles::Init(const double &r) {  R2 = r * r;  data.resize(1010);}void SystemOfParticles::Add(const double &x, const double &y) {  data[N].position = {x, y};  data[N].speed = {0, 0};  data[N].new_acceleration = {0, 0};  data[N].acceleration = {0, 0};  data[N].m = 1;  ++N;}void SystemOfParticles::Step(const double &width, const double &height) {  //Start Verlet algorithm  //Part 1 + 2#pragma omp parallel for  for (int i = 0; i < N; ++i) {    data[i].position += dt * data[i].speed + (dt / 2) * dt * data[i].acceleration;    data[i].new_acceleration = {0, -g};    data[i].new_acceleration -= data[i].b * data[i].speed;  }  //Part 3#pragma omp parallel for  for (int i = 0; i < N; ++i) {    for (int j = 0; j < i; ++j) {      Vector f = GetForceLD(data[i], data[j], rc, R2);      data[i].new_acceleration += f / data[i].m;    }    for (int j = i + 1; j < N; ++j) {      Vector f = GetForceLD(data[i], data[j], rc, R2);      data[i].new_acceleration += f / data[i].m;    }  }  //Part 4#pragma omp parallel for  for (int i = 0; i < N; ++i) {    data[i].speed += (dt / 2) * (data[i].new_acceleration + data[i].acceleration);    if ((data[i].position.y > height) && data[i].speed.y > 0)      data[i].speed.y *= -1;    if ((data[i].position.x > width) && data[i].speed.x > 0)      data[i].speed.x *= -1;    if ((data[i].position.x < 0) && data[i].speed.x < 0)      data[i].speed.x *= -1;    data[i].acceleration = data[i].new_acceleration;  }}const Vector &SystemOfParticles::GetIPosition(const int &i) const { return data[i].position; }const size_t &SystemOfParticles::GetNumbersOfParticles() const { return N; }